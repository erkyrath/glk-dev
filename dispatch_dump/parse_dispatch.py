#!/usr/bin/env python

# parse_dispatch.py: A script to parse the output of dispatch_dump, and
#   generate the Javascript data structures needed for gi_dispa.js.
#   It can also generate the infglk.h header file (for Inform 6),
#   and a human-readable form.
#
#   parse_dispatch.py --dispajs dispatch_dump.xml > proto_map.js
#   parse_dispatch.py --infglk  dispatch_dump.xml > infglk.h
#
# The --dispajs form will generate a bunch of lines of Javascript code --
# the autogenerated proto_map section of gi_dispa.js. When the Glk API
# is updated, I'll need to re-run this and replace that block.
#
# The --infglk form will generate the infglk.h header file.
#
# The --human form will generate a list of human-readable function
# descriptions.
#
# Just as an illustration: the C prototype of glk_put_char is:
#   void glk_put_char(char)
# The Glk selector number is 128, and the prototype code string is "1Cu:".
# So the generated Javascript object is:
#   new FuncSpec(128, "put_char", new Prototype([new ArgChar(false)], null))
# The FuncSpec, Prototype, and ArgChar classes are defined in gi_dispa.js.
# 
# This file also contains a draft of the code to generate the Javascript
# dispatch functions themselves. This draft is no longer used; I wrote
# it while working out the best way to put gi_dispa.js together. It's
# probably a bit out of date. The build_function() code in gi_dispa.js is
# the official (and actually-used) code.

import sys
import re
from xml.dom import minidom

target = None

args = sys.argv[ 1 : ]

if ('--dispajs' in args):
    args.remove('--dispajs')
    target = 'dispajs'
if ('--infglk' in args):
    args.remove('--infglk')
    target = 'infglk'
if ('--human' in args):
    args.remove('--human')
    target = 'human'

if (len(args) != 1):
    print('usage: parse_dispatch.py [ --dispajs | --infglk | --human ] dispatch_dump.xml')
    sys.exit(1)

filename = args[0]

glkversion = '???'
constants = {}
constantlist = []
functions = {}
classes = {}

def get_child_named(nod, nam):
    for el in nod.childNodes:
        if (el.nodeType != el.ELEMENT_NODE):
            continue
        if (el.nodeName == nam):
            return el
    raise ValueError('no such child: ' + nam)

def parse(filename):
    global glkversion
    
    doc = minidom.parse(filename)
    glkapi = get_child_named(doc, 'glkapi')
    name = glkapi.attributes.get('version')
    if (name):
        glkversion = name.value
    
    funcel = get_child_named(glkapi, 'constants')
    ls = [ el for el in funcel.childNodes if el.nodeType == el.ELEMENT_NODE ]
    for el in ls:
        attr = el.attributes
        id = int(attr.get('value').value)
        name = str(attr.get('name').value)
        constantlist.append(name)
        constants[name] = id
    
    funcel = get_child_named(glkapi, 'classes')
    ls = [ el for el in funcel.childNodes if el.nodeType == el.ELEMENT_NODE ]
    for el in ls:
        attr = el.attributes
        id = int(attr.get('value').value)
        name = str(attr.get('name').value)
        classes[id] = name
    
    funcel = get_child_named(glkapi, 'functions')
    ls = [ el for el in funcel.childNodes if el.nodeType == el.ELEMENT_NODE ]
    for el in ls:
        attr = el.attributes
        id = int(attr.get('id').value)
        name = str(attr.get('name').value)
        proto = str(attr.get('proto').value)
        functions[id] = Function(id, name, proto)
        
    doc.unlink()

class Function:
    def __init__(self, id, name, proto):
        self.id = id
        self.name = name
        self.proto = proto
        self.form = None

    def tojs(self):
        return 'new FuncSpec(%d, "%s", %s)' % (self.id, self.name, self.form.tojs())

    def tolabel(self):
        return '%s%s' % (self.name, self.form.tolabel())

    def genform(self):
        if (self.proto == '_'):
            self.form = None
            return
        (self.form, rest) = parseform(self.proto)
        if (rest):
            raise ValueError('extra stuff after prototype: ' + rest)

class ArgBase:
    def __init__(self):
        pass
    def booltojs(self, val):
        if (val):
            return 'true'
        else:
            return 'false'
    def tohuman(self):
        return self.tolabel()
    
class ArgString(ArgBase):
    def __init__(self):
        ArgBase.__init__(self)
    def __str__(self):
        return 'String'
    def tojs(self):
        return 'new ArgString()'
    def tolabel(self):
        return 'string'
    def tohuman(self):
        return 'string (8-bit array, null-terminated)'
        
class ArgUnicode(ArgBase):
    def __init__(self):
        ArgBase.__init__(self)
    def __str__(self):
        return 'Unicode'
    def tojs(self):
        return 'new ArgUnicode()'
    def tolabel(self):
        return 'unicode'
    def tohuman(self):
        return 'unicode (32-bit array, null-terminated)'
        
class ArgChar(ArgBase):
    def __init__(self, signed=None):
        ArgBase.__init__(self)
        self.signed = signed
    def __str__(self):
        if (self.signed is None):
            return 'Char:native'
        elif (self.signed):
            return 'Char:signed'
        else:
            return 'Char:unsigned'
    def tojs(self):
        if (self.signed is None):
            return 'arg_char_native'
        elif (self.signed):
            return 'arg_char_signed'
        else:
            return 'arg_char_unsigned'
    def tolabel(self):
        if (self.signed is None):
            return 'nativechar'
        elif (self.signed):
            return 'char'
        else:
            return 'uchar'
    def tohuman(self):
        if (self.signed is None):
            return 'native char'
        elif (self.signed):
            return 'signed char'
        else:
            return 'unsigned char'
        
class ArgInt(ArgBase):
    def __init__(self, signed=True):
        ArgBase.__init__(self)
        self.signed = signed
    def __str__(self):
        if (self.signed):
            return 'Int:signed'
        else:
            return 'Int:unsigned'
    def tojs(self):
        if (self.signed):
            return 'arg_int_signed'
        else:
            return 'arg_int_unsigned'
    def tolabel(self):
        if (self.signed):
            return 'int'
        else:
            return 'uint'
    def tohuman(self):
        if (self.signed):
            return 'signed int'
        else:
            return 'unsigned int'
        
class ArgClass(ArgBase):
    def __init__(self, name):
        ArgBase.__init__(self)
        self.name = name
    def __str__(self):
        return 'Class:%s' % (self.name,)
    def tojs(self):
        return 'arg_class_%s' % (self.name,)
    def tolabel(self):
        return self.name

class ArgStruct(ArgBase):
    def __init__(self, form):
        ArgBase.__init__(self)
        self.form = form
    def __str__(self):
        return 'Struct(%s)' % (self.form,)
    def tojs(self):
        return 'new ArgStruct(%s)' % (self.form.tojs(),)
    def tolabel(self):
        return '%s' % (self.form.tolabel('{}'),)
    def tohuman(self):
        pair = ('struct {', '}')
        return '%s' % (self.form.tolabel(pair),)

class ArgRef(ArgBase):
    def __init__(self, arg, passin=True, passout=True, nonnull=False):
        ArgBase.__init__(self)
        self.arg = arg
        self.passin = passin
        self.passout = passout
        self.nonnull = nonnull
        if (not passin and not passout):
            raise ValueError('Ref must have passin or passout')
        if (isinstance(arg, ArgString)):
            raise ValueError('Ref cannot be String')
        if (isinstance(arg, ArgUnicode)):
            raise ValueError('Ref cannot be Unicode')
    def __str__(self):
        if (self.passin and self.passout):
            val = 'in+out'
        elif (self.passin):
            val = 'in'
        elif (self.passout):
            val = 'out'
        else:
            val = '???'
        if (self.nonnull):
            val = val + ' nonnull'
        return 'Ref(%s %s)' % (self.arg, val)
    def tojs(self):
        return 'new ArgRef(%s, %s, %s, %s)' % (self.arg.tojs(), self.booltojs(self.passin), self.booltojs(self.passout), self.booltojs(self.nonnull))
    def tolabel(self):
        return '&%s' % (self.arg.tolabel(),)
    def tohuman(self):
        if self.passin and self.passout:
            dir = 'in/out'
        elif self.passin:
            dir = 'in'
        elif self.passout:
            dir = 'out'
        else:
            dir = '?'
        if self.nonnull:
            dir += ', mandatory'
        else:
            dir += ', optional'
        return 'reference (%s) to %s' % (dir, self.arg.tohuman(),)
    
class ArgArray(ArgBase):
    def __init__(self, arg, retained=False, passin=True, passout=True, nonnull=False):
        ArgBase.__init__(self)
        self.arg = arg
        self.passin = passin
        self.passout = passout
        self.nonnull = nonnull
        self.retained = retained
        if (not passin and not passout):
            raise ValueError('Array must have passin or passout')
        if (isinstance(arg, ArgString)):
            raise ValueError('Array cannot be String')
        if (isinstance(arg, ArgUnicode)):
            raise ValueError('Array cannot be Unicode')
        if (isinstance(arg, ArgRef)):
            raise ValueError('Array cannot be Ref')
    def __str__(self):
        if (self.passin and self.passout):
            val = 'in+out'
        elif (self.passin):
            val = 'in'
        elif (self.passout):
            val = 'out'
        else:
            val = '???'
        if (self.nonnull):
            val = val + ' nonnull'
        if (self.retained):
            val = val + ' retain'
        return 'Array(%s %s)' % (self.arg, val)
    def tojs(self):
        return 'new ArgArray(%s, %s, %s, %s, %s)' % (self.arg.tojs(), self.booltojs(self.retained), self.booltojs(self.passin), self.booltojs(self.passout), self.booltojs(self.nonnull))
    def tolabel(self):
        return '%sarray, arraylen' % (self.arg.tolabel(),)
    def tohuman(self):
        if self.passin and self.passout:
            dir = 'in/out'
        elif self.passin:
            dir = 'in'
        elif self.passout:
            dir = 'out'
        else:
            dir = '?'
        if self.nonnull:
            dir += ', mandatory'
        else:
            dir += ', optional'
        if self.retained:
            dir += ', retained'
        return 'array (%s) of %s; arraylen' % (dir, self.arg.tohuman(),)

class Arguments:
    def __init__(self, args, retarg=None):
        self.args = args
        self.retarg = retarg
        if (retarg):
            if (not isinstance(retarg, ArgRef)):
                raise ValueError('return arg must be Ref')
    def __str__(self):
        ret = ''
        if (self.retarg):
            ret = ' : %s' % (self.retarg,)
        ls = [ str(val) for val in self.args ]
        return '(%s%s)' % (', '.join(ls), ret)
    def tojs(self):
        retval = 'null'
        if (self.retarg):
            retval = self.retarg.tojs()
        ls = [ val.tojs() for val in self.args ]
        return 'new Prototype([%s], %s)' % (', '.join(ls), retval)
    def tolabel(self, paren='()'):
        retval = ''
        if (self.retarg):
            retval = ' => ' + self.retarg.arg.tolabel()
        ls = [ val.tolabel() for val in self.args ]
        return '%s%s%s%s' % (paren[0], ', '.join(ls), paren[1], retval)
    
regex_numbers = re.compile('[0-9]+')
regex_qualifiers = re.compile('[&<>+#!:]*')
        
def parseform(proto, top=True):
    val = regex_numbers.match(proto).group()
    proto = proto[ len(val) : ]
    argcount = int(val)

    args = []
    retarg = None
    
    for argix in range(argcount):
        retflag = None
        if (top and argix==argcount-1):
            retflag = [False]
        (arg, proto) = parsearg(proto, retflag)
        if (retflag and retflag[0]):
            retarg = arg
        else:
            args.append(arg)
    if (proto == ':'):
        proto = ''

    form = Arguments(args, retarg)
    return (form, proto)

def parsearg(proto, retflag=None):
    isreturn = False
    isref = False
    passin = False
    passout = False
    nonnull = False
    isarray = False
    retained = False

    val = regex_qualifiers.match(proto).group()
    proto = proto[ len(val) : ]

    for ch in val:
        if (ch == '&'):
            isref = True
            passin = True
            passout = True
        elif (ch == '>'):
            isref = True
            passin = True
        elif (ch == '<'):
            isref = True
            passout = True
        elif (ch == '+'):
            nonnull = True
        elif (ch == '#'):
            isarray = True
        elif (ch == '!'):
            retained = True
        elif (ch == ':'):
            isreturn = True
            isref = True
            passout = True
            nonnull = True

    if (isreturn):
        if (not retflag):
            raise ValueError('this argument position cannot return a value')
        retflag[0] = True

    ch = proto[0]
    proto = proto[ 1 : ]

    if (ch == 'S'):
        arg = ArgString()
    elif (ch == 'U'):
        arg = ArgUnicode()
    elif (ch == 'C'):
        ch = proto[0]
        proto = proto[ 1 : ]
        if (ch == 'n'):
            arg = ArgChar(None)
        elif (ch == 's'):
            arg = ArgChar(True)
        elif (ch == 'u'):
            arg = ArgChar(False)
        else:
            raise ValueError('unknown Char modifier: C'+ch)
    elif (ch == 'I'):
        ch = proto[0]
        proto = proto[ 1 : ]
        if (ch == 's'):
            arg = ArgInt(True)
        elif (ch == 'u'):
            arg = ArgInt(False)
        else:
            raise ValueError('unknown Int modifier: I'+ch)
    elif (ch == 'Q'):
        ch = proto[0]
        proto = proto[ 1 : ]
        classnum = ord(ch) - ord('a')
        classname = classes[classnum]
        arg = ArgClass(classname)
    elif (ch == '['):
        (form, proto) = parseform(proto, False)
        ch = proto[0]
        proto = proto[ 1 : ]
        if (ch != ']'):
            raise ValueError('internal prototype did not end')
        arg = ArgStruct(form)
    else:
        raise ValueError('unknown type character: '+ch)

    if (isarray):
        if (not isref):
            raise ValueError('Array must be a reference')
        arg = ArgArray(arg, retained=retained, passin=passin, passout=passout, nonnull=nonnull)
    elif (isref):
        arg = ArgRef(arg, passin=passin, passout=passout, nonnull=nonnull)

    if (isinstance(arg, ArgStruct)):
        raise ValueError('a Struct must be a reference')
        
    return (arg, proto)

# ------------------------------------------------------------------------
# Here begins the unused draft of build_function().

def convert_arg(arg, passin, val):
    if (isinstance(arg, ArgInt)):
        if (passin):
            if (not arg.signed):
                return '%s' % (val,)
            else:
                return '%s & 0xFFFFFFFF' % (val,)
        else:
            return '0'
    elif (isinstance(arg, ArgChar)):
        if (passin):
            if (not arg.signed):
                return '%s & 0xFF' % (val,)
            else:
                return 'cast_signed_char(%s)' % (val,)
        else:
            return '0'
    elif (isinstance(arg, ArgClass)):
        if (passin):
            return 'class_%s_from_id(%s)' % (arg.name, val)
        else:
            return 'null'
    else:
        raise ValueError('convert_arg: unsupported arg: %s' % (arg,))

def unconvert_arg(arg, val):
    if (isinstance(arg, ArgInt)):
        return '%s >>> 0' % (val,)
    elif (isinstance(arg, ArgChar)):
        if (not arg.signed):
            return '%s & 0xFF' % (val,)
        else:
            return 'uncast_signed_char(%s)' % (val,)
    elif (isinstance(arg, ArgClass)):
        return 'class_%s_to_id(%s)' % (arg.name, val)
    else:
        raise ValueError('unconvert_arg: unsupported arg: %s' % (arg,))
    
def build_function(func):
    out = []
    locals = {}

    out.append('// no local vars')
    out.append('// %d: %s %s' % (func.id, func.name, func.form))
    form = func.form
    retarg = None
    if form.retarg:
        retarg = form.retarg.arg
    
    argpos = 0
    argjoin = []
    for ix in range(len(form.args)):
        arg = form.args[ix]
        tmpvar = 'glka'+str(ix)
        argjoin.append(tmpvar)
        locals[tmpvar] = True
        if (isinstance(arg, ArgInt)
            or isinstance(arg, ArgChar)
            or isinstance(arg, ArgClass)):
            val = convert_arg(arg, True, 'callargs[%d]' % (argpos,))
            out.append('%s = %s;' % (tmpvar, val))
            argpos += 1
        elif (isinstance(arg, ArgRef)):
            refarg = arg.arg
            out.append('if (callargs[%d] == 0) {' % (argpos,))
            if (arg.nonnull):
                out.append('  throw("glk %s: null argument");' % (func.name,))
            else:
                out.append('  %s = null;' % (tmpvar,))
            out.append('} else {')
            if (isinstance(refarg, ArgInt)
                or isinstance(refarg, ArgChar)
                or isinstance(refarg, ArgClass)):
                out.append('  %s = Glk.RefBox();' % (tmpvar,))
                val = convert_arg(refarg, arg.passin, 'VM.ReadWord(callargs[%d])' % (argpos,))
                out.append('  %s.set_value(%s);' % (tmpvar, val))
            elif (isinstance(refarg, ArgStruct)):
                subargs = refarg.form.args
                out.append('  %s = Glk.RefStruct(%d);' % (tmpvar, len(subargs)))
                for jx in range(len(subargs)):
                    val = convert_arg(subargs[jx], arg.passin, 'VM.ReadField(callargs[%d], %d)' % (argpos, jx))
                    out.append('  %s.push_field(%s);' % (tmpvar, val))
            else:
                raise ValueError('buildfunc: unsupported refarg: %s' % (refarg,))
            out.append('}')
            argpos += 1
        elif (isinstance(arg, ArgArray)):
            locals['glklen'] = True
            refarg = arg.arg
            out.append('if (callargs[%d] == 0) {' % (argpos,))
            if (arg.nonnull):
                out.append('  throw("glk %s: null argument");' % (func.name,))
            else:
                out.append('  %s = null;' % (tmpvar,))
            out.append('} else {')
            out.append('  glklen = callargs[%d];' % (argpos+1,))
            out.append('  %s = Array(glklen);' % (tmpvar,))
            if (isinstance(refarg, ArgChar)):
                macro = 'Byte'
                refsize = 1
            else:
                macro = 'Word'
                refsize = 4
            if (refarg.signed):
                issigned = 1
            else:
                issigned = 0
            if (arg.passin):
                locals['ix'] = True
                locals['jx'] = True
                out.append('  for (ix=0, jx=callargs[%d]; ix<glklen; ix++, jx+=%d) {' % (argpos, refsize))
                val = convert_arg(refarg, True, 'VM.Read%s(jx)' % (macro,))
                out.append('    %s[ix] = %s;' % (tmpvar, val))
                out.append('  }')
            if (arg.retained):
                out.append('  retain_array(%s, glklen, %d, %d);' % (tmpvar, refsize, issigned))
            out.append('}')
            argpos += 2
        elif (isinstance(arg, ArgString) or isinstance(arg, ArgUnicode)):
            if (isinstance(arg, ArgString)):
                macro = 'Byte'
                refsize = 1
            else:
                macro = 'Word'
                refsize = 4
            out.append('%s = Array();' % (tmpvar,))
            out.append('for (jx=callargs[%d]; true; jx+=%d) {' % (argpos, refsize))
            out.append('  ix = VM.Read%s(jx);' % (macro,))
            out.append('  if (ix == 0) break;')
            out.append('  %s.push(ix);' % (tmpvar,))
            out.append('}')
            argpos += 1
        else:
            raise ValueError('buildfunc: unsupported arg: %s' % (arg,))

    if (retarg):
        retval = 'glkret = '
    else:
        retval = ''
    out.append('%sGlk.%s(%s);' % (retval, func.name, ', '.join(argjoin)))

    argpos = 0
    for ix in range(len(form.args)):
        arg = form.args[ix]
        tmpvar = 'glka'+str(ix)
        if (isinstance(arg, ArgInt)
            or isinstance(arg, ArgChar)
            or isinstance(arg, ArgClass)):
            argpos += 1
        elif (isinstance(arg, ArgRef)):
            refarg = arg.arg
            if (arg.passout):
                out.append('if (%s) {' % (tmpvar,))
                if (isinstance(refarg, ArgInt)
                    or isinstance(refarg, ArgChar)
                    or isinstance(refarg, ArgClass)):
                    val = unconvert_arg(refarg, '%s.get_value()' % (tmpvar,))
                    out.append('  VM.WriteWord(callargs[%d], %s);' % (argpos, val))
                elif (isinstance(refarg, ArgStruct)):
                    subargs = refarg.form.args
                    for jx in range(len(subargs)):
                        val = unconvert_arg(subargs[jx], '%s.get_field(%d)' % (tmpvar, jx))
                        out.append('  VM.WriteField(callargs[%d], %d, %s);' % (argpos, jx, val))
                else:
                    raise ValueError('buildfunc: unsupported refarg: %s' % (refarg,))
                out.append('}')
            argpos += 1
        elif (isinstance(arg, ArgArray)):
            refarg = arg.arg
            if (arg.passout and not arg.retained):
                out.append('if (%s) {' % (tmpvar,))
                locals['ix'] = True
                locals['jx'] = True
                if (isinstance(refarg, ArgChar)):
                    macro = 'Byte'
                    refsize = 1
                else:
                    macro = 'Word'
                    refsize = 4
                out.append('  for (ix=0, jx=callargs[%d]; ix<glklen; ix++, jx+=%d) {' % (argpos, refsize))
                val = unconvert_arg(refarg, '%s[ix]' % (tmpvar,))
                out.append('    VM.Write%s(jx, %s)' % (macro, val))
                out.append('  }')
                out.append('}')
            argpos += 2
        elif (isinstance(arg, ArgString) or isinstance(arg, ArgUnicode)):
            argpos += 1
        else:
            raise ValueError('buildfunc: unsupported arg: %s' % (arg,))
            
    if (retarg):
        val = unconvert_arg(retarg, 'glkret')
        out.append('return %s;' % (val,))
    else:
        out.append('return 0;')

    ls = list(locals.keys())
    if ls:
        ls.sort()
        out[0] = 'var %s;' % (', '.join(ls),)
    return '\n'.join(out)

# End of build_function().
# ------------------------------------------------------------------------

parse(filename)
idarray = list(functions.keys())
idarray.sort()

for id in idarray:
    func = functions[id]
    func.genform()

def make_javascript():
    print('// The following table is auto-generated by parse_dispatch.py.')
    print('// Generated for Glk API version %s' % (glkversion,))
    print('/* Some literal ArgInt and ArgChar objects, used to speed')
    print('   up the proto_map construction. These globals are also')
    print('   used in the build_function() call in gi_dispa.js. */')
    print('var arg_int_unsigned = new ArgInt(false);')
    print('var arg_int_signed = new ArgInt(true);')
    print('var arg_char_unsigned = new ArgChar(false);')
    print('var arg_char_native = new ArgChar(null);')
    print('var arg_char_signed = new ArgChar(true);')
    for (ix, id) in sorted(classes.items()):
        print('var arg_class_%s = new ArgClass("%s");' % (id, id,))
    print('var proto_map = {')
    for ix in range(len(idarray)):
        id = idarray[ix]
        islast = (ix == len(idarray)-1)
        func = functions[id]
        if (func.form):
            print('// %d (0x%03X): %s - %s' % (func.id, func.id, func.name, func.proto))
            print('%d : %s%s' % (func.id, func.tojs(), ('' if islast else ',')))
    print('};')
    print('// End of auto-generated table.')

def make_infglk():
    print('! infglk.h -- auto-generated by parse_dispatch.py.')
    print('! Generated for Glk API version %s' % (glkversion,))
    print()

    print('! Declare as a system header unless we are in the I7 environment.')
    print('! (I7 does not use the System_file directive.)')
    print('#ifndef NI_BUILD_COUNT;')
    print('System_file;')
    print('#endif;  ! NI_BUILD_COUNT')
    print()
    
    print('#ifndef INFGLK_H;')
    print('Constant INFGLK_H = 1;')
    print('#ifdef TARGET_GLULX;')
    print()

    for key in constantlist:
        val = constants[key]
        print('Constant %s = %d;' % (key, val))
    print()
    
    for id in idarray:
        func = functions[id]
        if (func.form):
            if (func.form.retarg):
                print('[ glk_%s _vararg_count ret;' % (func.name,))
                print('  ! glk_%s' % (func.tolabel(),))
                print('  @glk %d _vararg_count ret;' % (func.id,))
                print('  return ret;')
                print('];')
            else:
                print('[ glk_%s _vararg_count;' % (func.name,))
                print('  ! glk_%s' % (func.tolabel(),))
                print('  @glk %d _vararg_count 0;' % (func.id,))
                print('  return 0;')
                print('];')
            print()
            
    print('#endif;  ! TARGET_GLULX')
    print('#endif;  ! INFGLK_H')

def make_human():
    for id in idarray:
        func = functions[id]
        if (not func.form):
            continue
        form = func.form
        hexid = hex(func.id).upper().replace('X', 'x')
        print('(%s) glk_%s:' % (hexid, func.name))
        ix = 0
        for arg in form.args:
            num = str(ix)
            if isinstance(arg, ArgArray):
                num = '%d,%d' % (ix, ix+1,)
                ix += 2
            else:
                num = str(ix)
                ix += 1
            print('  arg %s: %s' % (num, arg.tohuman()))
        if not form.args:
            print('  (no arguments)')
        if form.retarg:
            assert isinstance(form.retarg, ArgRef)
            print('  returns: %s' % (form.retarg.arg.tohuman(),))
        else:
            print('  (no return value)')
        print()

if (not target):
    print('Found', len(constants), 'constants,', len(classes), 'classes, and', len(functions), 'functions.')
elif (target == 'dispajs'):
    make_javascript()
elif (target == 'infglk'):
    make_infglk()
elif (target == 'human'):
    make_human()


